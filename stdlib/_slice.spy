"""
SPy Slice module

A Slice similar to CPython's
"""

from operator import OpSpec, MetaArg
from types import NoneType

from __spy__ import interp_list

@struct
class tuple3:
    start: int
    stop: int
    step: int

@struct
class Slice:
    start: int
    start_is_none: int # bool
    stop: int
    stop_is_none: int # bool
    step: int
    step_is_none: int # bool

    @blue.metafunc
    def __new__(m_cls, n_start, n_stop, n_step) -> OpSpec:    
        
        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (int, int, int):
            def impl1(_start:int, _stop:int, _step:int) -> Slice:
                return Slice.__make__(_start, 0, _stop, 0, _step, 0)
            return OpSpec(impl1, interp_list[MetaArg](n_start, n_stop, n_step))
        
        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (NoneType, int, int):
            def impl2(_start:NoneType, _stop:int, _step:int) -> Slice:
                return Slice.__make__(0, 1, _stop, 0, _step, 0)
            return OpSpec(impl2, interp_list[MetaArg](n_start, n_stop, n_step))
    
        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (int, NoneType, int):
            def impl3(_start:int, _stop:NoneType, _step:int) -> Slice:
                return Slice.__make__(_start, 0, 0, 1, _step, 0)
            return OpSpec(impl3, interp_list[MetaArg](n_start, n_stop, n_step))
    
        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (int, int, NoneType):
            def impl4(_start:int, _stop:int, _step:NoneType) -> Slice:
                return Slice.__make__(_start, 0, _stop, 0, 1, 1)
            return OpSpec(impl4, interp_list[MetaArg](n_start, n_stop, n_step))
    
        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (NoneType, NoneType, int):
            def impl5(_start:NoneType, _stop:NoneType, _step:int) -> Slice:
                return Slice.__make__(0, 1, 0, 1, _step, 0)
            return OpSpec(impl5, interp_list[MetaArg](n_start, n_stop, n_step))
    
        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (NoneType, int, NoneType):
            def impl6(_start:None, _stop:int, _step:None) -> Slice:
                return Slice.__make__(0, 1, _stop, 0, 1, 1)
            return OpSpec(impl6, interp_list[MetaArg](n_start, n_stop, n_step))

        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (int, NoneType, NoneType):
            def impl7(_start:int, _stop:None, _step:None) -> Slice:
                return Slice.__make__(_start, 0, 0, 1, 1, 1)
            return OpSpec(impl7, interp_list[MetaArg](n_start, n_stop, n_step))
    
        if (n_start.static_type, n_stop.static_type, n_step.static_type) == (NoneType, NoneType, NoneType):
            def impl8(_start:NoneType, _stop:NoneType, _step:NoneType) -> Slice:
                return Slice.__make__(0, 1, 0, 1, 1, 1)
            return OpSpec(impl8, interp_list[MetaArg](n_start, n_stop, n_step))
        
        return OpSpec.NULL
    
    def indices(self, length: int) -> tuple3:
        _step: int = 1
        if not self.step_is_none: _step = self.step
        if _step == 0:
            raise ValueError("slice step cannot be zero")


        if length < 0:
            raise ValueError("length should not be negative")
        
        # Find lower and upper bounds for start and stop.
        _lower: int = 0
        if _step < 0: _lower = -1
        _upper: int = length
        if _step < 0: _upper = length - 1

        # Compute start.
        _start: int = 0
        if self.start_is_none:
            if _step < 0:
                _start = _upper
            else:
                _start = _lower
        else:
            _start = self.start
            if _start < 0:
                _start = max(_start + length, _lower)
            else:
                _start = min(_start, _upper)

        # Compute stop.
        _stop: int = 0
        if self.stop_is_none != 0:
            if _step < 0:
                _stop = _lower
            else:
                _stop = _upper
        else:
            _stop = self.stop
            if _stop < 0:
                _stop = max(_stop + length, _lower)
            else:
                _stop = min(_stop, _upper)

        return tuple3(_start, _stop, _step)