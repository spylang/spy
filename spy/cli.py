import asyncio
import os
import pdb as stdlib_pdb  # to distinguish from the "--pdb" option
import re
import sys
import time
import traceback
from dataclasses import dataclass
from functools import wraps
from pathlib import Path
from typing import (
    Annotated,
    Any,
    Awaitable,
    Callable,
    Optional,
    Protocol,
)

import click
import py.path
import typer
from typer import Argument, Option
from typer.core import TyperGroup
from typer.rich_utils import rich_format_help

from spy.analyze.importing import ImportAnalyzer
from spy.backend.c.cbackend import CBackend
from spy.backend.spy import FQN_FORMAT, SPyBackend
from spy.build.config import BuildConfig, BuildTarget, OutputKind
from spy.doppler import ErrorMode
from spy.errors import SPyError
from spy.magic_py_parse import magic_py_parse
from spy.textbuilder import Color
from spy.util import (
    cleanup_spyc_files,
    colors_coordinates,
    format_colors_as_json,
    highlight_src_maybe,
)
from spy.vendored.dataclass_typer import dataclass_typer
from spy.vm.b import B
from spy.vm.debugger.spdb import SPdb
from spy.vm.function import W_ASTFunc, W_FuncType
from spy.vm.module import W_Module
from spy.vm.vm import SPyVM

GLOBAL_VM: Optional[SPyVM] = None


class AppGroupConfig(TyperGroup):
    # This makes the commands show up in the hlep in the order we prefer;
    # if the command is not present in this fixed list, it defaults to the end
    cmd_order = [
        "pyparse",
        "parse",
        "imports",
        "symtable",
        "redshift",
        "colorize",
        "execute",
        "build",
        "cleanup",
    ]

    def list_commands(self, ctx: click.Context) -> list:
        key = lambda cmd: self.cmd_order.index(cmd) if cmd in self.cmd_order else 999
        return sorted(self.commands, key=key)

    # Command Aliases
    # To alias a command, include the aliases in the command name,
    # separated by commas or a |
    # From https://github.com/fastapi/typer/issues/132

    _CMD_SPLIT_P = re.compile(r" ?[,|] ?")

    def get_command(self, ctx, cmd_name) -> click.Command | None:
        cmd_name = self._group_cmd_name(self.commands.values(), cmd_name)
        result = super().get_command(ctx, cmd_name)
        return result

    def _group_cmd_name(self, group_command_names, default_name) -> str:
        for cmd in group_command_names:
            if cmd.name and default_name in self._CMD_SPLIT_P.split(cmd.name):
                return cmd.name
        return default_name


app = typer.Typer(
    pretty_exceptions_enable=False, cls=AppGroupConfig, no_args_is_help=True
)


def pyproject_entry_point() -> Any:
    """
    This is called by the script generated by pyproject.toml
    """
    if sys.platform == "emscripten":
        print(
            "The 'spy' command does not work in a pyodide venv running under node. "
            "Please use python -m spy"
        )
        sys.exit(1)
    return app()


def spy_command(*cmd_args, **cmd_kwargs) -> Callable:  # type: ignore
    """
    Decorator to turn an async function into a SPy subcommand
    The async function should take a single dataclass as an argument
    Arguments to the spy_command decorator are passed to typer.app.command, i.e. "name"
    """

    def syncify(f: Callable[[Base_Args], Any]) -> Callable[[Base_Args], Any]:
        @wraps(f)
        def inner(args: Base_Args) -> Any:
            if sys.platform == "emscripten":
                return asyncio.create_task(_pyodide_main(f, args))
            else:
                return asyncio.run(_run_user_func_and_catch_spy_errors(f, args))

        return inner

    def wrapper(user_function: Callable[[Base_Args], Awaitable[Any]]) -> None:
        app.command(*cmd_args, **cmd_kwargs)(dataclass_typer(syncify(user_function)))

    return wrapper


async def _pyodide_main(user_func: Callable, args: Base_Args) -> None:
    """
    For some reasons, it seems that pyodide doesn't print exceptions
    uncaught exceptions which escapes an asyncio task. This is a small wrapper
    to ensure that we display a proper traceback in that case
    """
    try:
        await _run_user_func_and_catch_spy_errors(user_func, args)
    except BaseException:
        traceback.print_exc()


async def _run_user_func_and_catch_spy_errors(
    user_func: Callable, args: Base_Args
) -> None:
    """
    A wrapper around the user provided command,
    to catch/display SPy errors and to implement --pdb
    """
    try:
        return await user_func(args)
    except SPyError as e:
        ## traceback.print_exc()
        ## print()

        # special case SPdbQuit
        if e.etype == "W_SPdbQuit":
            print("SPdbQuit")
            sys.exit(1)

        print(e.format(use_colors=True))

        if args.spdb:
            # post-mortem applevel debugger
            assert GLOBAL_VM is not None
            w_tb = e.w_exc.w_tb
            assert w_tb is not None
            spdb = SPdb(GLOBAL_VM, w_tb)
            spdb.post_mortem()
        elif args.pdb:
            # post-mortem interp-level debugger
            info = sys.exc_info()
            stdlib_pdb.post_mortem(info[2])
        sys.exit(1)
    except Exception as e:
        if not args.pdb:
            raise
        traceback.print_exc()
        info = sys.exc_info()
        stdlib_pdb.post_mortem(info[2])
        sys.exit(1)


# Lifecycle Functions


class Init_Args(Protocol):
    error_mode: ErrorMode
    filename: Path


async def _init_vm(args: Init_Args) -> SPyVM:
    global GLOBAL_VM

    if args.filename.suffix == ".py":
        print(
            f"Error: {args.filename} is a .py file, not a .spy file.", file=sys.stderr
        )
        sys.exit(1)

    srcdir = args.filename.parent
    vm = await SPyVM.async_new()

    GLOBAL_VM = vm

    vm.robust_import_caching = True  # don't raise if .spyc are unreadable/invalid

    vm.path.append(str(srcdir))
    if args.error_mode == "warn":
        args.error_mode = "lazy"

        def emit_warning(err: SPyError) -> None:
            print(Color.set("yellow", "[warning] "), end="")
            print(err.format())

        vm.emit_warning = emit_warning
    return vm


# Commands and Arguments
# Each command should be written as an async function which takes
# a single dataclass as its only argument
# Decorate these with the @spy_dataclass(name="...") decorator to turn them
# into commands. Aliases may be created by separating multiple
#  names with , or |
@dataclass
class Base_Args:
    """These arguments can be applied to any spy command/subcommand"""

    timeit: Annotated[
        bool,
        Option("--timeit", help="Print execution time"),
    ] = False

    pdb: Annotated[
        bool,
        Option("--pdb", help="Enter interp-level debugger in case of error"),
    ] = False

    spdb: Annotated[
        bool,
        Option("--spdb", help="Enter app-level debugger in case of error"),
    ] = False

    error_mode: Annotated[
        ErrorMode,
        Option(
            "-E",
            "--error-mode",
            help="Handling strategy for static errors",
            click_type=click.Choice(ErrorMode.__args__),
        ),
    ] = "eager"


@dataclass
class Filename_Optional_Args:
    """Filename is optional for the cleanup command only"""

    filename: Annotated[
        Optional[Path],
        Argument(help=""),
    ] = None


@dataclass
class Filename_Required_Args:
    filename: Annotated[
        Path,
        Argument(help=""),
    ]


@dataclass
class General_Args_With_Filename(Base_Args, Filename_Required_Args): ...


@dataclass
class Cleanup_Args(Base_Args, Filename_Optional_Args): ...


@spy_command(name="c  | cleanup")
async def cleanup(args: Cleanup_Args) -> None:
    """Remove .spyc cache files from the provided path or cwd if vm is None)"""
    if args.filename:
        vm = await _init_vm(
            args
        )  # TODO There's a type error here - we know args.filename is not None but mypy can't infer that for some reason
    else:
        vm = None
    paths = vm.path if vm is not None else [os.getcwd()]
    _do_cleanup(paths)


def _do_cleanup(paths: list[str]) -> None:
    removed_count = cleanup_spyc_files(paths)

    if removed_count == 0:
        print("No .spyc files found")
    else:
        print(f"Removed {removed_count} .spyc file(s)")


@spy_command(name="P  | pyparse")
async def pyparse(args: General_Args_With_Filename) -> None:
    """Dump the Python AST"""
    with open(args.filename) as f:
        src = f.read()
    mod = magic_py_parse(src)
    mod.pp()


@spy_command(name="I  | imports")
async def imports(args: General_Args_With_Filename) -> None:
    """Dump the (recursive) list of imports"""
    modname = args.filename.stem
    vm = await _init_vm(args)

    importer = ImportAnalyzer(vm, modname)
    importer.parse_all()
    importer.pp()


@spy_command(name="S  | symtable")
async def symtable(args: General_Args_With_Filename) -> None:
    """Dump the symtables"""
    modname = args.filename.stem
    vm = await _init_vm(args)

    importer = ImportAnalyzer(vm, modname)
    importer.parse_all()
    scopes = importer.analyze_scopes(modname)
    scopes.pp()


@dataclass
class _parse_mixin:
    colorize: Annotated[
        bool,
        Option(
            "-C",
            "--colorize",
            help="Output the pre-redshifted AST with blue / red text colors.",
        ),
    ] = False

    colorize_source: Annotated[
        bool,
        Option(
            "--colorize-source",
            help="Show the original source code, with colors detected by redshifting",
        ),
    ] = False

    format: Annotated[
        str,
        Option(
            "--format",
            help="Output format for --colorize (ansi or json)",
            click_type=click.Choice(["ansi", "json"]),
        ),
    ] = "ansi"


@dataclass
class Parse_Args(Base_Args, _parse_mixin, Filename_Required_Args): ...


# TODO rebase and add the --format argument back in


@spy_command(name="p  | parse")
async def parse(args: Parse_Args) -> None:
    """Dump the SPy AST"""
    modname = args.filename.stem
    vm = await _init_vm(args)

    importer = ImportAnalyzer(vm, modname)
    importer.parse_all()

    orig_mod = importer.getmod(modname)

    if args.colorize_source:
        importer.import_all()
        vm.ast_color_map = {}
        vm.redshift(error_mode=args.error_mode)
        coords = colors_coordinates(orig_mod, vm.ast_color_map)
        if args.format == "json":
            print(format_colors_as_json(coords))
        else:
            print(highlight_sourcecode(args.filename, coords))
        return

    if not args.colorize:
        orig_mod.pp()
    else:
        orig_mod.pp(vm=vm)


@dataclass
class _redshift_mixin:
    full_fqn: Annotated[
        bool,
        Option("--full-fqn", help="Show full FQNs in redshifted modules"),
    ] = False

    human_readable: Annotated[
        bool,
        Option("--human-readable", help="Show full FQNs in redshifted modules"),
    ] = False


@dataclass
class Redshift_Args(Base_Args, _redshift_mixin, Filename_Required_Args): ...


@spy_command(name="rs | redshift")
async def redshift(args: Redshift_Args) -> None:
    """
    Perform redshift and dump the result
    """

    modname = args.filename.stem
    vm = await _init_vm(args)

    importer = ImportAnalyzer(vm, modname)
    importer.parse_all()
    importer.import_all()

    vm.ast_color_map = {}
    vm.redshift(error_mode=args.error_mode)

    if args.human_readable:
        dump_spy_mod(vm, modname, args.full_fqn)
    else:  # not args.human_readable
        dump_spy_mod_ast(vm, modname)


@dataclass
class _run_mixin:
    redshift: Annotated[
        bool,
        Option("-s", "--redshift", help="Redshift the module before executing"),
    ] = False


@dataclass
class Run_Args(Base_Args, _run_mixin, Filename_Required_Args): ...


@spy_command(name="r  | x | run")
async def _run(args: Run_Args) -> None:
    """Execute the file in the vm"""  # TODO make this the default operation when no command is given
    modname = args.filename.stem
    vm = await _init_vm(args)

    importer = ImportAnalyzer(vm, modname)
    importer.parse_all()
    importer.import_all()
    w_mod = vm.modules_w[modname]

    # If we're not redshifting, execute and return immediately
    if not args.redshift:
        execute_spy_main(args, vm, w_mod)
        return

    # Redshift the code here
    vm.redshift(error_mode=args.error_mode)

    execute_spy_main(args, vm, w_mod)


@dataclass
class Build_Args(General_Args_With_Filename):
    cwrite: Annotated[
        bool,
        Option("--cwrite", help="Generate the C code; do not compile"),
    ] = False

    cdump: Annotated[
        bool,
        Option("--cdump", help="Dump the generated C code to stdout; do not compile"),
    ] = False

    build_dir: Annotated[
        Optional[Path],
        Option(
            "-b",
            "--build-dir",
            help="Directory to store generated files (defaults to build/ next to the "
            ".spy file)",
        ),
    ] = None

    opt_level: Annotated[
        int,
        Option(
            "-O",
            metavar="LEVEL",
            help="Optimization level",
        ),
    ] = 0

    debug_symbols: Annotated[
        bool,
        Option("-g", help="Generate debug symbols"),
    ] = False

    release_mode: Annotated[
        bool,
        Option("--release", help="enable release mode"),
    ] = False

    target: Annotated[
        BuildTarget,
        Option(
            "-t",
            "--target",
            help="Compilation target",
            click_type=click.Choice(BuildTarget.__args__),
        ),
    ] = "native"

    output_kind: Annotated[
        OutputKind,
        Option(
            "-k",
            "--output-kind",
            help="Output kind",
            click_type=click.Choice(OutputKind.__args__),
        ),
    ] = "exe"


@spy_command(name="b  | build")
async def build(args: Build_Args) -> None:
    """Compile the generated C code"""
    modname = args.filename.stem
    vm = await _init_vm(args)

    importer = ImportAnalyzer(vm, modname)
    importer.parse_all()
    importer.import_all()

    vm.ast_color_map = {}
    vm.redshift(error_mode=args.error_mode)

    config = BuildConfig(
        target=args.target,
        kind=args.output_kind,
        build_type="release" if args.release_mode else "debug",
    )

    cwd = py.path.local(".")
    build_dir = get_build_dir(args)
    dump_c = args.cwrite and args.cdump
    backend = CBackend(vm, modname, config, build_dir, dump_c=dump_c)

    backend.cwrite()
    backend.write_build_script()
    assert backend.build_script is not None

    if args.cwrite:
        cfiles = ", ".join([f.relto(cwd) for f in backend.cfiles])
        build_script = backend.build_script.relto(cwd)
        print(f"C files:      {cfiles}")
        print(f"Build script: {build_script}")
        return

    outfile = backend.build()
    executable = outfile.relto(cwd)
    if executable == "":
        # outfile is not in a subdir of cwd, let's display the full path
        executable = str(outfile)
    print(f"[{config.build_type}] {executable} ")


def get_build_dir(args: Build_Args) -> py.path.local:
    if args.build_dir is not None:
        build_dir = args.build_dir
    else:
        assert args.filename is not None
        srcdir = args.filename.parent
        build_dir = srcdir / "build"

    # print(f"Build dir:    {build_dir}")
    build_dir.mkdir(exist_ok=True, parents=True)
    return py.path.local(str(build_dir))


def execute_spy_main(args: Run_Args, vm: SPyVM, w_mod: W_Module) -> None:
    w_main_functype = W_FuncType.parse("def() -> None")
    w_main = w_mod.getattr_maybe("main")
    if w_main is None:
        print("Cannot find function main()")
        return

    vm.typecheck(w_main, w_main_functype)
    assert isinstance(w_main, W_ASTFunc)

    # find the redshifted version, if necessary
    if args.redshift:
        assert not w_main.is_valid
        assert w_main.w_redshifted_into is not None
        w_main = w_main.w_redshifted_into
        assert w_main.redshifted
    else:
        assert not w_main.redshifted

    a = time.time()
    w_res = vm.fast_call(w_main, [])
    b = time.time()
    if args.timeit:
        print(f"main(): {b - a:.3f} seconds", file=sys.stderr)
    assert w_res is B.w_None


def highlight_sourcecode(sourcefile: Path, coords_dict: dict) -> str:
    reset = "\033[0m"
    ansi_colors = {"red": "\033[41m\033[30m", "blue": "\033[44m\033[30m"}
    with open(sourcefile) as f:
        lines = f.readlines()

    highlighted_lines = []

    for i, line in enumerate(lines, start=1):
        if i not in coords_dict:
            highlighted_lines.append(line)
            continue

        # Segments in input order: later spans overwrite earlier ones
        spans = [
            (int(s.split(":")[0]), int(s.split(":")[1]), color)
            for s, color in coords_dict[i]
        ]

        # Track color per character using segments
        line_len = len(line)
        color_map = [None] * line_len
        for start, end, color in spans:
            for j in range(start, min(end + 1, line_len)):
                color_map[j] = color

        # Build line from contiguous segments
        result = []
        current_color = None
        cursor = 0
        while cursor < line_len:
            c = color_map[cursor]
            if c != current_color:
                if current_color is not None:
                    result.append(reset)
                if c is not None:
                    # Find contiguous run of this color
                    run_end = cursor
                    while run_end < line_len and color_map[run_end] == c:
                        run_end += 1
                    result.append(ansi_colors[c] + line[cursor:run_end] + reset)
                    cursor = run_end
                    current_color = None
                    continue
                current_color = c
            else:
                result.append(line[cursor])
            cursor += 1

        highlighted_lines.append("".join(result))
    return "".join(highlight_src_maybe("spy", line) for line in highlighted_lines)


def dump_spy_mod_ast(vm: SPyVM, modname: str) -> None:
    for fqn, w_obj in vm.fqns_by_modname(modname):
        if isinstance(w_obj, W_ASTFunc) and w_obj.color == "red" and w_obj.fqn == fqn:
            print(f"`{fqn}` = ", end="")
            w_obj.funcdef.pp()
            print()


def dump_spy_mod(vm: SPyVM, modname: str, full_fqn: bool) -> None:
    fqn_format: FQN_FORMAT = "full" if full_fqn else "short"
    b = SPyBackend(vm, fqn_format=fqn_format)
    print(b.dump_mod(modname))
