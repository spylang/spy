from typing import TYPE_CHECKING, Annotated

from spy.errors import WIP
from spy.vm.b import B
from spy.vm.primitive import W_I32, W_Dynamic
from spy.vm.str import W_Str
from spy.vm.struct import W_Struct, W_StructType
from spy.vm.w import W_Object, W_Type

from . import UNSAFE
from .misc import sizeof
from .ptr import W_RawPtr, W_RawPtrType, w_raw_ptr

if TYPE_CHECKING:
    from spy.vm.vm import SPyVM


@UNSAFE.builtin_func(color="blue", kind="generic")
def w_raw_alloc(vm: "SPyVM", w_T: W_Type) -> W_Dynamic:
    w_ptrtype = vm.fast_call(w_raw_ptr, [w_T])  # unsafe::raw_ptr[i32]
    assert isinstance(w_ptrtype, W_RawPtrType)
    ITEMSIZE = sizeof(w_T)

    # unsafe::raw_ptr[i32]::raw_alloc
    #
    # this is a special builtin function, its C equivalent is automatically
    # generated by c.Context.new_ptr_type
    @vm.register_builtin_func(w_ptrtype.fqn, "raw_alloc")
    def w_fn(vm: "SPyVM", w_n: W_I32) -> Annotated[W_RawPtr, w_ptrtype]:
        n = vm.unwrap_i32(w_n)
        size = ITEMSIZE * n
        addr = vm.ll.call("spy_gc_alloc_mem", size)
        return W_RawPtr(w_ptrtype, addr, n)  # type: ignore

    return w_fn


@UNSAFE.builtin_func(color="blue")
def w_mem_read(vm: "SPyVM", w_T: W_Type) -> W_Dynamic:
    T = Annotated[W_Object, w_T]

    # unsafe::mem_read[T]
    @vm.register_builtin_func("unsafe", "mem_read", [w_T.fqn])
    def w_mem_read_T(vm: "SPyVM", w_addr: W_I32) -> T:
        addr = vm.unwrap_i32(w_addr)
        return generic_mem_read(vm, addr, w_T)

    return w_mem_read_T


@UNSAFE.builtin_func(color="blue")
def w_mem_write(vm: "SPyVM", w_T: W_Type) -> W_Dynamic:
    T = Annotated[W_Object, w_T]

    # unsafe::mem_write[T]
    @vm.register_builtin_func("unsafe", "mem_write", [w_T.fqn])
    def w_mem_write_T(vm: "SPyVM", w_addr: W_I32, w_val: T) -> None:
        addr = vm.unwrap_i32(w_addr)
        generic_mem_write(vm, addr, w_T, w_val)

    return w_mem_write_T


def generic_mem_read(vm: "SPyVM", addr: int, w_T: W_Type) -> W_Object:
    if w_T is B.w_i32:
        return vm.wrap(vm.ll.mem.read_i32(addr))
    elif w_T is B.w_f64:
        return vm.wrap(vm.ll.mem.read_f64(addr))
    elif w_T is B.w_str:
        v_addr, v_length = vm.ll.mem.read_ptr(addr)
        assert v_length == 1
        return W_Str.from_ptr(vm, v_addr)
    elif isinstance(w_T, W_RawPtrType):
        v_addr, v_length = vm.ll.mem.read_ptr(addr)
        return W_RawPtr(w_T, v_addr, v_length)
    elif isinstance(w_T, W_StructType):
        # read the struct by value, field by field
        values_w = {}
        for w_field in w_T.iterfields_w():
            fname = w_field.name
            offset = w_field.offset
            values_w[fname] = generic_mem_read(vm, addr + offset, w_field.w_T)
        return W_Struct(w_T, values_w)
    else:
        raise WIP(f"Cannot read memory of type `{w_T.fqn.human_name}`")


def generic_mem_write(vm: "SPyVM", addr: int, w_T: W_Type, w_val: W_Object) -> None:
    if w_T is B.w_i32:
        v = vm.unwrap_i32(w_val)
        vm.ll.mem.write_i32(addr, v)
    elif w_T is B.w_f64:
        v = vm.unwrap_f64(w_val)
        vm.ll.mem.write_f64(addr, v)
    elif w_T is B.w_str:
        assert isinstance(w_val, W_Str)
        v = w_val.ptr
        assert 0 < v < 2**31 - 1
        vm.ll.mem.write_ptr(addr, v, 1)
    elif isinstance(w_T, W_RawPtrType):
        assert isinstance(w_val, W_RawPtr)
        vm.ll.mem.write_ptr(addr, w_val.addr, w_val.length)
    elif isinstance(w_T, W_StructType):
        assert isinstance(w_val, W_Struct)
        # write the struct by value, field by field
        for w_field in w_T.iterfields_w():
            fname = w_field.name
            offset = w_field.offset
            generic_mem_write(vm, addr + offset, w_field.w_T, w_val.values_w[fname])
    else:
        raise WIP(f"Cannot write memory of type `{w_T.fqn.human_name}`")
